##单例模式写法对比

### 优质单例模式实现考虑因素 ###
单例模式的目的是使某个类在程序运行过程中只产生一个实例(这个单个实例在程序运行中全局可见),为了确保达到这一特性,需要在实现单例模式的代码考虑一下因素:
1. 多线程,并发getInstance
2. 单例初始化时机
3. 性能效率优化
4. java版本
5. 类加载器个数


### 单例模式使用场景 ###
1. 例如:类A每new一次都很消耗资源或者耗时, 如果加之这个类频繁被使用那就会非常消耗内存或者耗时.造成资源浪费.为了避免类A占用过多的资源或者让A始终保持在程序运行期中,那就可以使用单例模式.一个单例A对象, 就可以解决多次使用中的时间空间的浪费.
常见使用场景: 对数据库的操作, 访问IO, 线程池, 网络请求等
2. 例如:类B的实例应该有且只有一个.如果new出多个这样的类可能会导致程序行为异常,结果与逻辑不一致等.比如多人同时编辑一个文件,如果不进行版本管理很容易出现覆盖.比如Android系统通过binder获取的各种Service都是单例

### 单例模式实现方式 ###
按加载时机分为:
1. 饿汉模式3种(在成员变量中直接固化复制对象)
2. 懒汉模式()
按实现方式:
1. 双重加锁DCL
2. 内部类方式
3. 枚举方式
4. 通过Map容器来管理到单例

单例模式实现的核心思想:
让类的构造函数为私有, 仅提供一个实例的静态方法getIntance(),必须保证实例的方法是线程安全的.并防止反序列化, 反射, 克隆, 多个加载器等情况下生成新的实例对象.

线程安全的实现方式:
1.饿汉模式3种 懒加载N 返序列化N 反射N 克隆N 性能:急切初始化 **急切加载推荐**
2.懒汉模式(对方法syncronise) 懒加载Y 返序列化N 反射N 克隆N 性能:存在性能问题,每次getInstance都会进行同步 **不推荐**
3.DCL双重检查锁定 懒加载Y 返序列化N 反射N 克隆N 性能:JDK<1.5失效 **可用**
4.静态内部类单例 懒加载Y 反序列化N 反射N 克隆N 性能:无性能问题 **推荐**
5.枚举单例 懒加载Y 反序列化Y 反射Y 克隆Y 性能: JDK < 1.5不支持 **最推荐**

**懒汉模式比饿汉模式优秀的原因就是:
懒汉模式可以在代码中支配何时产生单例.而饿汉模式在系统装载类的时候就做了初始化操作,导致无法支配恶汉单例的加载时机**

![](http://static.open-open.com/lib/uploadImg/20170310/20170310151925_221.jpg)

### 线程安全 ###
单例模式必须要保证线程安全.
在只考虑一个类加载器的情况下，“饿汉方式”实现的单例（在系统运行起来装载类的时候就进行初始化实例的操作，由 JVM 虚拟机来保证一个类的初始化方法在多线程环境中被正确加锁和同步，所以）是线程安全的，而“懒汉”方式则需要注意了，先来看一种最简单的“懒汉方式”的单例
该方式没有考虑多线程,可能出现线程AgetInstance实例的时候singleton == null,但是在通过条件的那一刻线程B也通过了这个判断,最后 new出了两个实例.所以这个种方式不是最佳写法!
![](http://static.open-open.com/lib/uploadImg/20170310/20170310151925_527.jpg)

解决多线程问题的一个方法就是加锁:
![](http://static.open-open.com/lib/uploadImg/20170310/20170310151925_168.png)

方法加锁迫使每个线程在进入这个方法之前都要先等别的线程离开该方法,即加锁的getInstance能也只能由一个线程去执行.但是致命的缺点是效率太低.
每个线程在每次getInstance执行时都会进行一次方法同步.而事实上实例创建完成后,同步就没有必要了.因为单例已经不可能为null.这在高并发的情况下必然会拖垮性能.所以该方法依然不推荐.

将同步方法改为同步代码块:
![](http://static.open-open.com/lib/uploadImg/20170310/20170310151925_267.png)
同步代码块并不能保证线程安全.AB两线程同时通过singleton == null的判断,那么依旧会产生两个实力.只不过AB依次生成实例而已.
所以使用DCL:
![](http://static.open-open.com/lib/uploadImg/20170310/20170310151925_267.png)

第一次check 避免不必要的同步,
第二次check 保证线程安全

双重检查锁定（DCL）方式也是延迟加载的，它唯一的问题是，由于 Java 编译器允许处理器乱序执行，在 JDK 版本小于 1.5 时会有 DCL 失效的问题（原因解释详见附录 2）。当然，现在大家使用的 JDK 普遍都已超过 1.4，只要在定义单例时加上 1.5 及以上版本具体化了的 volatile 关键字，即可保证执行的顺序，从而使单例起效。所以 DCL 方式是推荐的一种方式。

Android 中鼎鼎大名的 Universal Image Loader 和 EventBus 都是采用了这种方式的单例

延迟加载的“静态内部类”方式:
![](http://static.open-open.com/lib/uploadImg/20170310/20170310151926_460.png)
这种方式利用了 classloder 的机制来保证初始化 instance 时只会有一个。需要注意的是：虽然它的名字中有“静态”两字，但它是属于“懒汉模式”的！！这种方式的 Singleton 类被装载时，只要 SingletonHolder 类还没有被主动使用，instance 就不会被初始化。只有在显式调用  getInstance() 方法时，才会装载 SingletonHolder 类，从而实例化对象。

静态内部类”方式基本上弥补了 DCL 方式在 JDK 版本低于 1.5 时高并发环境失效的缺陷。《Java并发编程实践》中也指出 DCL 方式的“优化”是丑陋的，对静态内部类方式推崇备至。但是可能因为同大家创建单例时的思考习惯不太一致（根据单例模式的特点，一般首先想到的是通过 instance 判空来确保单例），此方式并不特别常见，然而它是所有懒加载的单例实现中适用范围最广、限制最小、最为推荐的一种。（下述的枚举方式限制也很少，但是可能更不易理解。）

**至此，所有的常用懒汉模式都已讨论完毕，仅推荐“双重检查锁定”（DCL）方式（符合思考逻辑）和“静态内部类”方式（任意 JDK 版本可用），它们共同的特点是：懒加载、线程安全、效率较高。**

饿汉式因为在类创建的同时就实例化了静态对象，其资源已经初始化完成，所以第一次调用时更快，优势在于速度和反应时间，但是不管此单例会不会被使用，在程序运行期间会一直占据着一定的内存；而懒汉式是延迟加载的，优点在于资源利用率高，但第一次调用时的初始化工作会导致性能延迟，以后每次获取实例时也都要先判断实例是否被初始化，造成些许效率损失。

![](http://static.open-open.com/lib/uploadImg/20170310/20170310151926_687.png)
（注： readResolve() 是反序列化操作提供的一个很特别的钩子函数，它在从流中读取对象的  readObject(ObjectInputStream) 方法之后被调用，可以让开发人员控制对象的反序列化。我们在  readResolve() 方法中用原来的 instance 替换掉从流中读取到的新创建的 instance，就可以避免使用序列化方式破坏了单例。）


使用反射调利用私有构造器也是可以破坏单例的，要防止此情况发生，可以在私有的构造器中加一个判断，需要创建的对象不存在就创建；存在则说明是第二次调用，抛出 RuntimeException 提示。修改私有构造函数代码如下：
![](http://static.open-open.com/lib/uploadImg/20170310/20170310151928_408.png)


## 登记式单例——使用 Map 容器来管理单例模式 ##

使用时通过统一的接口来获取某个单例.在程序的初始，我们将一组单例类型注入到一个统一的管理类中来维护，即将这些实例存放在一个 Map 登记薄中，在使用时则根据 key 来获取对象对应类型的单例对象。对于已经登记过的实例，从 Map 直接返回实例；对于没有登记的，则先登记再返回。

从而在对用户隐藏具体实现、降低代码耦合度的同时，也降低了用户的使用成本。简易版代码实现如下：
![](http://static.open-open.com/lib/uploadImg/20170310/20170310151928_112.jpg)

